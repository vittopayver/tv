<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Player</title>

<!-- mux.js: demux MPEG-TS → fMP4 para MediaSource API do Chrome -->
<script src="https://cdn.jsdelivr.net/npm/mux.js@6.3.0/dist/mux.js"></script>

<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { width:100%; height:100%; background:#000; overflow:hidden; }
  video { width:100%; height:100%; display:block; background:#000; }
</style>
</head>
<body>

<video id="v" controls autoplay muted playsinline></video>

<script>
const STREAM = 'http://46.151.196.223:14432/';

const v   = document.getElementById('v');
const ms  = new MediaSource();
v.src     = URL.createObjectURL(ms);

ms.addEventListener('sourceopen', () => {

  // mux.js converte MPEG-TS → fMP4 fragmentado que o Chrome entende
  const transmuxer = new muxjs.mp4.Transmuxer({
    keepOriginalTimestamps: true,
  });

  // Mime type fMP4 — suportado nativamente pelo Chrome
  const mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
  if (!MediaSource.isTypeSupported(mime)) {
    console.warn('Tentando mime alternativo...');
  }

  const sb = ms.addSourceBuffer(mime);
  sb.mode  = 'sequence';

  const queue  = [];
  let flushing = false;

  function flushQueue() {
    if (flushing || queue.length === 0 || sb.updating) return;
    flushing = true;
    const chunk = queue.shift();
    try { sb.appendBuffer(chunk); }
    catch(e) { console.error('appendBuffer:', e); flushing = false; }
  }

  sb.addEventListener('updateend', () => {
    flushing = false;
    flushQueue();
    // Tenta dar play assim que tiver dados suficientes
    if (v.readyState >= 2 && v.paused) v.play().catch(()=>{});
  });

  // Quando o transmuxer tiver segmentos prontos, enfileira
  transmuxer.on('data', segment => {
    // Junta initSegment + data em um único ArrayBuffer
    const data = new Uint8Array(
      segment.initSegment.byteLength + segment.data.byteLength
    );
    data.set(segment.initSegment, 0);
    data.set(segment.data, segment.initSegment.byteLength);
    queue.push(data.buffer);
    flushQueue();
  });

  transmuxer.on('done', () => {
    // Todos os segmentos foram processados
    if (!sb.updating) {
      try { ms.endOfStream(); } catch(e){}
    }
  });

  // Fetch do stream em chunks e alimenta o transmuxer
  fetch(STREAM, { mode: 'cors' })
    .then(res => {
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const reader = res.body.getReader();

      function pump() {
        reader.read().then(({ done, value }) => {
          if (done) {
            transmuxer.flush();
            return;
          }
          // Alimenta o mux.js com os bytes crus do MPEG-TS
          transmuxer.push(value);
          pump();
        }).catch(e => console.error('read error:', e));
      }

      pump();
    })
    .catch(e => {
      console.error('Fetch falhou:', e.message);
      // Tenta no-cors como último recurso
      fetch(STREAM, { mode: 'no-cors' })
        .then(r => r.arrayBuffer())
        .then(buf => {
          transmuxer.push(new Uint8Array(buf));
          transmuxer.flush();
        })
        .catch(e2 => console.error('no-cors falhou:', e2.message));
    });
});

// Eventos
v.addEventListener('playing', () => console.log('▶ Reproduzindo'));
v.addEventListener('error',   () => console.error('Erro vídeo:', v.error?.code));
</script>
</body>
</html>
